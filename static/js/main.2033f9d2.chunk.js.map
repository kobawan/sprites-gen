{"version":3,"sources":["components/imageGenerator/imageGenerator.module.scss","utils/loadImages.ts","components/imageGenerator/ImageGenerator.tsx","serviceWorker.js","index.js"],"names":["module","exports","loadMultipleImages","urls","Promise","all","map","url","resolve","img","Image","src","onload","onerror","loadImage","then","imgs","filter","Boolean","getImageChunks","sizeHeight","sizeWidth","cols","rows","commonOptions","dw","dh","sw","sh","chunks","row","col","push","sx","sy","window","location","hostname","match","ReactDOM","render","canvasRef","useRef","useState","width","setWidth","height","setHeight","files","setFiles","shouldSplitImage","setShouldSplitImage","setCols","setRows","error","setError","useDropzone","onDrop","useCallback","file","accept","getRootProps","getInputProps","FileInfo","i","key","className","cx","styles","fileName","onClick","name","useEffect","current","ctx","getContext","clearRect","length","reader","FileReader","result","readAsDataURL","Math","floor","naturalWidth","naturalHeight","requestAnimationFrame","resWidth","resHeight","imageChunks","ceil","chunk","j","chunkIndex","random","imgIndex","dx","dy","getAllChunksRandomly","forEach","drawImage","wrapper","ref","form","onChange","title","content","label","input","type","e","currentTarget","value","min","dropzone","checkbox","footer","preventDefault","toDataURL","anchor","document","createElement","href","download","click","disabled","downloadButton","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.2033f9d2.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"wrapper\":\"imageGenerator_wrapper__2tPb5\",\"form\":\"imageGenerator_form__3sxNv\",\"title\":\"imageGenerator_title__23EN1\",\"content\":\"imageGenerator_content__23stf\",\"row\":\"imageGenerator_row__34Ura\",\"fileName\":\"imageGenerator_fileName__c4_Nq\",\"dropzone\":\"imageGenerator_dropzone__V9EFo\",\"label\":\"imageGenerator_label__2Jaxb\",\"input\":\"imageGenerator_input__2WH26\",\"checkbox\":\"imageGenerator_checkbox__30TQ5\",\"footer\":\"imageGenerator_footer__35QiS\",\"downloadButton\":\"imageGenerator_downloadButton__sin8v\",\"error\":\"imageGenerator_error__3rkcQ\"};","export const loadImage = (url: string): Promise<HTMLImageElement|undefined> => {\n  return new Promise((resolve) => {\n    const img = new Image();\n    img.src = url;\n    img.onload = () => resolve(img);\n    img.onerror = () => resolve();\n  });\n};\n\nexport const loadMultipleImages = (urls: string[]): Promise<HTMLImageElement[]> => {\n  return Promise.all(\n    urls.map(url => loadImage(url))\n  ).then(imgs => imgs.filter(Boolean)) as Promise<HTMLImageElement[]>;\n}\n","import React, { useRef, useState, useEffect, useCallback } from \"react\";\nimport { useDropzone } from \"react-dropzone\";\nimport cx from \"classnames\";\nimport styles from \"./imageGenerator.module.scss\";\nimport { loadMultipleImages } from \"../../utils/loadImages\";\n\nconst MAX_CHUNKS = 400;\n\ninterface ImageChunks {\n  sx: number;\n  sy: number;\n  sw: number;\n  sh: number;\n  dw: number;\n  dh: number;\n}\n\ninterface DrawImageOptions extends ImageChunks {\n  img: CanvasImageSource;\n  dx: number;\n  dy: number;\n}\n\ninterface GetImageChunksOptions {\n  sizeWidth: number;\n  sizeHeight: number;\n  cols: number;\n  rows: number;\n}\n\ninterface GetAllChunksRandomlyOptions {\n  resWidth: number;\n  resHeight: number;\n  imageChunks: ImageChunks[];\n  imgs: HTMLImageElement[];\n  sizeWidth: number;\n  sizeHeight: number;\n}\n\nconst getImageChunks = ({\n  sizeHeight,\n  sizeWidth,\n  cols,\n  rows,\n}: GetImageChunksOptions) => {\n  const commonOptions = {\n    dw: sizeWidth,\n    dh: sizeHeight,\n    sw: sizeWidth,\n    sh: sizeHeight,\n  }\n  let chunks: ImageChunks[] = [];\n  for(let row = 0; row < rows; row++) {\n    for(let col = 0; col < cols; col++) {\n      chunks.push({\n        ...commonOptions,\n        sx: col * sizeWidth,\n        sy: row * sizeHeight,\n      })\n    }\n  }\n  return chunks;\n}\n\nconst getAllChunksRandomly = ({\n  resWidth,\n  resHeight, \n  sizeWidth,\n  sizeHeight,\n  imageChunks,\n  imgs,\n}: GetAllChunksRandomlyOptions): DrawImageOptions[] => {\n  const cols = Math.ceil(resWidth / sizeWidth);\n  const rows = Math.ceil(resHeight / sizeHeight);\n  const chunk = [];\n\n  for(let i = 0; i < cols; i++) {\n    for (let j = 0; j < rows; j++) {\n      const chunkIndex = imageChunks.length === 1\n        ? 0\n        : Math.floor(Math.random() * imageChunks.length);\n      const imgIndex = imgs.length === 1\n        ? 0\n        : Math.floor(Math.random() * imgs.length);\n      chunk.push({\n        img: imgs[imgIndex],\n        dx: i * sizeWidth,\n        dy: j * sizeHeight,\n        ...imageChunks[chunkIndex],\n      });\n    }\n  }\n\n  return chunk;\n}\n\nconst readFiles = (imgs: File[]): Promise<string[]> => {\n  return Promise.all(imgs.map(file => {\n    return new Promise((resolve) => {\n      const reader = new FileReader();\n      reader.onload = () => resolve(reader.result as string);\n      reader.onerror = () => resolve(\"\");\n      reader.readAsDataURL(file);\n    });\n  }));\n}\n\nexport const ImageGenerator: React.FC = () => {\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  const [width, setWidth] = useState(0);\n  const [height, setHeight] = useState(0);\n  const [files, setFiles] = useState<File[]>([]);\n  const [shouldSplitImage, setShouldSplitImage] = useState(false);\n  const [cols, setCols] = useState(1);\n  const [rows, setRows] = useState(1);\n  const [error, setError] = useState(\"\");\n\n  const {\n    getRootProps,\n    getInputProps,\n  } = useDropzone({\n    onDrop: useCallback((file: File[]) => setFiles(file), []),\n    accept: \"image/png, image/jpeg\"\n  });\n\n  const removeFile = (name: string) => {\n    setFiles(files.filter(file => file.name !== name));\n  }\n\n  const FileInfo = files.map((file, i) => {\n    return (\n      <span\n        key={i}\n        className={cx(styles.row, styles.fileName)}\n        onClick={() => removeFile(file.name)}\n      >\n        {file.name}\n      </span>\n    );\n  })\n\n  useEffect(() => {\n    if(!width || !height || !canvasRef.current) {\n      return;\n    }\n\n    const ctx = canvasRef.current.getContext('2d');\n    if(ctx) {\n      ctx.clearRect(0, 0, width, height);\n    }\n\n    if(!files.length) {\n      return;\n    }\n    if(cols > 30 || rows > 30 || ((cols || 1) * (rows || 1) > MAX_CHUNKS)) {\n      setError(\"Image has too many chunks to split. Please lower column or row value\");\n      return;\n    }\n\n    readFiles(files)\n      .then(urls => urls.filter(Boolean))\n      .then(urls => loadMultipleImages(urls))\n      .then(imgs => {\n        if(!imgs.length || !canvasRef.current) {\n          return;\n        }\n        const ctx = canvasRef.current.getContext('2d');\n        if(!ctx) {\n          return;\n        }\n\n        const sizeWidth = shouldSplitImage ? Math.floor(imgs[0].naturalWidth / cols) : imgs[0].naturalWidth;\n        const sizeHeight = shouldSplitImage ? Math.floor(imgs[0].naturalHeight / rows) : imgs[0].naturalHeight;\n\n        window.requestAnimationFrame(() => {\n          ctx.clearRect(0, 0, width, height);\n          getAllChunksRandomly({\n            resHeight: height,\n            resWidth: width,\n            sizeWidth,\n            sizeHeight,\n            imageChunks: getImageChunks({ sizeWidth, sizeHeight, cols, rows }),\n            imgs,\n          }).forEach(({ img, sx, sy, sw, sh, dx, dy, dw, dh }) => {\n            ctx.drawImage(img, sx, sy, sw, sh, dx, dy, dw, dh);\n          })\n        });\n      });\n  }, [width, height, files, cols, rows, shouldSplitImage, canvasRef])\n\n  const downloadImg = (e: React.MouseEvent<HTMLButtonElement>) => {\n    e.preventDefault();\n    if (!canvasRef.current) return;\n    const src = canvasRef.current.toDataURL(\"image/png\");\n    const anchor = document.createElement(\"a\");\n    anchor.href = src;\n    anchor.download = `${width}x${height}-generated.png`;\n    anchor.click();\n  };\n\n  const updateShouldSplit = () => {\n    if(shouldSplitImage) {\n      setCols(1);\n      setRows(1);\n    }\n    setShouldSplitImage(!shouldSplitImage)\n  }\n\n  return (\n    <div className={styles.wrapper}>\n      {!!width && !!height && (\n        <canvas ref={canvasRef} width={width} height={height}></canvas>\n      )}\n      <form className={styles.form} onChange={() => setError(\"\")}>\n        <h3 className={styles.title}>Image generator</h3>\n        <div className={styles.content}>\n          <div className={styles.row}>\n            <label className={styles.label}>Resolution Width</label>\n            <input\n              className={styles.input}\n              type=\"number\"\n              onChange={(e) => setWidth(+e.currentTarget.value)}\n              min={1}\n            />\n          </div>\n          <div className={styles.row}>\n            <label className={styles.label}>Resolution Height</label>\n            <input\n              className={styles.input}\n              type=\"number\"\n              onChange={(e) => setHeight(+e.currentTarget.value)}\n              min={1}\n            />\n          </div>\n          <div {...getRootProps()} className={cx(styles.row, styles.dropzone)}>\n            <input {...getInputProps()} />\n            <span>Drag 'n' drop some files here, or click to select files</span>\n          </div>\n          {FileInfo}\n          <div className={styles.row}>\n            <label className={styles.label}>Split sprites:</label>\n            <input\n              className={cx(styles.input, styles.checkbox)}\n              type=\"checkbox\"\n              onChange={updateShouldSplit}\n            />\n          </div>\n          {shouldSplitImage && <>\n            <div className={styles.row}>\n              <label className={styles.label}>Columns</label>\n              <input\n                className={styles.input}\n                type=\"number\"\n                onChange={(e) => setCols(+e.currentTarget.value)}\n                min={1}\n              />\n            </div>\n            <div className={styles.row}>\n              <label className={styles.label}>Rows</label>\n              <input\n                className={styles.input}\n                type=\"number\"\n                onChange={(e) => setRows(+e.currentTarget.value)}\n                min={1}\n              />\n            </div>\n          </>}\n        </div>\n        <div className={styles.footer}>\n          <button\n            onClick={downloadImg}\n            disabled={!width || !height || !files.length || !!error}\n            className={styles.downloadButton}\n          >\n            Download\n          </button>\n          {error && <span className={styles.error}>{error}</span>}\n        </div>\n      </form>\n    </div>\n  );\n}","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.scss\";\nimport { ImageGenerator } from \"./components/imageGenerator/ImageGenerator\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(<ImageGenerator />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}